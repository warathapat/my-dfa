<!DOCTYPE html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>เครื่องมือสร้าง Finite State Machine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Sarabun", sans-serif;
        touch-action: none;
      }
      canvas {
        cursor: crosshair;
        background-color: #f0f4f8;
        border-radius: 0.5rem;
      }
      .info-box {
        background-color: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(5px);
      }
    </style>
  </head>
  <body
    class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-4"
  >
    <div class="w-full max-w-6xl mx-auto">
      <h1 class="text-3xl font-bold text-center text-gray-700 mb-4">
        เครื่องมือสร้างและจำลอง Finite State Machine
      </h1>

      <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
        <!-- Canvas Area -->
        <div class="lg:col-span-2 bg-white p-4 rounded-lg shadow-md">
          <canvas id="fsm-canvas"></canvas>
        </div>

        <!-- Controls and Info Area -->
        <div class="flex flex-col gap-4">
          <div class="info-box p-4 rounded-lg shadow-md border border-gray-200">
            <h2 class="text-xl font-bold mb-3">ทดสอบสตริง</h2>
            <input
              type="text"
              id="test-string"
              placeholder="ป้อนสตริงที่นี่..."
              class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"
            />
            <div
              id="result"
              class="mt-3 text-lg font-semibold text-center h-8"
            ></div>
          </div>

          <div
            id="selection-editor"
            class="info-box p-4 rounded-lg shadow-md border border-gray-200 hidden"
          >
            <h2 class="text-xl font-bold mb-3" id="editor-title">แก้ไข</h2>
            <div id="editor-content" class="space-y-3"></div>
          </div>

          <div class="info-box p-4 rounded-lg shadow-md border border-gray-200">
            <h2 class="text-xl font-bold mb-3">ตั้งค่าการแสดงผล</h2>
            <div class="flex items-center justify-center gap-4">
              <label class="text-gray-700">ขนาดตัวอักษร:</label>
              <button
                id="decrease-font"
                class="px-3 py-1 bg-gray-200 hover:bg-gray-300 rounded-md font-bold"
              >
                -
              </button>
              <span id="font-size-display" class="w-8 text-center font-semibold"
                >16</span
              >
              <button
                id="increase-font"
                class="px-3 py-1 bg-gray-200 hover:bg-gray-300 rounded-md font-bold"
              >
                +
              </button>
            </div>
          </div>

          <div class="info-box p-4 rounded-lg shadow-md border border-gray-200">
            <h2 class="text-xl font-bold mb-3">ส่งออกแผนภาพ</h2>
            <div class="flex flex-col gap-2">
              <button
                id="export-png-btn"
                class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded transition"
              >
                Export as PNG
              </button>
              <button
                id="export-transparent-png-btn"
                class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded transition"
              >
                Export as Transparent PNG
              </button>
            </div>
          </div>

          <div class="info-box p-4 rounded-lg shadow-md border border-gray-200">
            <h2 class="text-xl font-bold mb-3">วิธีใช้งาน</h2>
            <ul class="list-disc list-inside space-y-2 text-gray-700">
              <li>
                <strong class="text-blue-600">ย้าย Label:</strong>
                คลิกค้างที่ข้อความของเส้นเชื่อมแล้วลาก
              </li>
              <li>
                <strong class="text-blue-600">ย้ายสถานะ:</strong>
                คลิกค้างแล้วลากสถานะ (จะมี Smart Guide ช่วยจัดตำแหน่ง)
              </li>
              <li>
                <strong class="text-blue-600">สร้างเส้นเชื่อม:</strong> กด
                <kbd
                  class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg"
                  >Shift</kbd
                >
                ค้างไว้ แล้วลากจากสถานะหนึ่งไปอีกสถานะ
              </li>
              <li>
                <strong class="text-blue-600">ปรับความโค้งเส้นเชื่อม:</strong>
                คลิกค้างที่กลางเส้นเชื่อมแล้วลาก
              </li>
              <li>
                <strong class="text-blue-600">ลบ:</strong> คลิกเลือกวัตถุแล้วกด
                <kbd>Delete</kbd> หรือใช้ปุ่มในเมนูแก้ไข
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <script>
      // --- Global Settings ---
      let globalFontSize = 16;
      let guideLines = [];

      // --- Class Definitions ---
      class State {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.radius = 30;
          this.text = "";
          this.isAccept = false;
          this.isStart = false;
        }
        contains(x, y) {
          return Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2) < this.radius;
        }
        draw(ctx, isSelected, isCurrent) {
          ctx.save();
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
          ctx.fillStyle = isCurrent ? "#68D391" : "white";
          ctx.fill();
          ctx.strokeStyle = isSelected ? "#4299E1" : "#4A5568";
          ctx.lineWidth = isSelected ? 4 : 2;
          ctx.stroke();
          if (this.isAccept) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius - 6, 0, 2 * Math.PI);
            ctx.strokeStyle = "#4A5568";
            ctx.lineWidth = 2;
            ctx.stroke();
          }
          ctx.fillStyle = "#2D3748";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `${globalFontSize}px Sarabun`;
          ctx.fillText(this.text, this.x, this.y);
          ctx.restore();
        }
      }
      class Transition {
        constructor(startState, endState) {
          this.startState = startState;
          this.endState = endState;
          this.text = "";
          this.anchorAngle = 0;
          this.isSelfLoop = startState === endState;
          this.labelOffsetX = 0;
          this.labelOffsetY = 0;
          if (this.isSelfLoop) {
            this.anchorAngle = -Math.PI / 2;
          }
        }
        getControlPoints() {
          if (this.isSelfLoop) {
            const s = this.startState,
              r = s.radius,
              angle = this.anchorAngle,
              spread = Math.PI / 4,
              loopSize = 45;
            const startAngle = angle - spread,
              endAngle = angle + spread;
            const startPos = {
              x: s.x + r * Math.cos(startAngle),
              y: s.y + r * Math.sin(startAngle),
            };
            const endPos = {
              x: s.x + r * Math.cos(endAngle),
              y: s.y + r * Math.sin(endAngle),
            };
            const cpDist = r + loopSize;
            const cp1 = {
              x: s.x + cpDist * Math.cos(angle - spread * 0.8),
              y: s.y + cpDist * Math.sin(angle - spread * 0.8),
            };
            const cp2 = {
              x: s.x + cpDist * Math.cos(angle + spread * 0.8),
              y: s.y + cpDist * Math.sin(angle + spread * 0.8),
            };
            return { startPos, endPos, cp1, cp2 };
          } else {
            const dx = this.endState.x - this.startState.x,
              dy = this.endState.y - this.startState.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist === 0)
              return { cp: { x: this.startState.x, y: this.startState.y } };
            const normalX = -dy / dist,
              normalY = dx / dist;
            const midX = this.startState.x + dx / 2,
              midY = this.startState.y + dy / 2;
            const anchorLength = (Math.sin(this.anchorAngle) * dist) / 2;
            const cp = {
              x: midX + normalX * anchorLength,
              y: midY + normalY * anchorLength,
            };
            return { cp };
          }
        }
        // **FIXED**: Added missing helper functions for calculating curve points
        getPointOnQuadraticBezier(t, start, cp, end) {
          const x =
            (1 - t) * (1 - t) * start.x +
            2 * (1 - t) * t * cp.x +
            t * t * end.x;
          const y =
            (1 - t) * (1 - t) * start.y +
            2 * (1 - t) * t * cp.y +
            t * t * end.y;
          return { x, y };
        }
        getPointOnCubicBezier(t, start, cp1, cp2, end) {
          const x =
            Math.pow(1 - t, 3) * start.x +
            3 * Math.pow(1 - t, 2) * t * cp1.x +
            3 * (1 - t) * t * t * cp2.x +
            Math.pow(t, 3) * end.x;
          const y =
            Math.pow(1 - t, 3) * start.y +
            3 * Math.pow(1 - t, 2) * t * cp1.y +
            3 * (1 - t) * t * t * cp2.y +
            Math.pow(t, 3) * end.y;
          return { x, y };
        }

        getBaseLabelPosition() {
          if (this.isSelfLoop) {
            const s = this.startState,
              r = s.radius,
              angle = this.anchorAngle,
              loopSize = 45;
            const apex = {
              x: s.x + (r + loopSize + 10) * Math.cos(angle),
              y: s.y + (r + loopSize + 10) * Math.sin(angle),
            };
            return apex;
          } else {
            const { cp } = this.getControlPoints();
            const start = this.startState,
              end = this.endState;
            const midCurveX = 0.25 * start.x + 0.5 * cp.x + 0.25 * end.x;
            const midCurveY = 0.25 * start.y + 0.5 * cp.y + 0.25 * end.y;
            return { x: midCurveX, y: midCurveY };
          }
        }
        labelContains(ctx, x, y) {
          if (!this.text) return false;
          const basePos = this.getBaseLabelPosition();
          const finalX = basePos.x + this.labelOffsetX;
          const finalY = basePos.y + this.labelOffsetY;
          ctx.font = `${globalFontSize}px Sarabun`;
          const textMetrics = ctx.measureText(this.text);
          const width = textMetrics.width + 8;
          const height = globalFontSize + 4;
          return (
            x >= finalX - width / 2 &&
            x <= finalX + width / 2 &&
            y >= finalY - height / 2 &&
            y <= finalY + height / 2
          );
        }
        contains(x, y) {
          const threshold = 15;
          if (this.isSelfLoop) {
            const { startPos, endPos, cp1, cp2 } = this.getControlPoints();
            for (let t = 0; t <= 1; t += 0.05) {
              const p = this.getPointOnCubicBezier(
                t,
                startPos,
                cp1,
                cp2,
                endPos
              );
              if (Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2) < threshold)
                return true;
            }
          } else {
            const { cp } = this.getControlPoints();
            for (let t = 0; t <= 1; t += 0.05) {
              const p = this.getPointOnQuadraticBezier(
                t,
                this.startState,
                cp,
                this.endState
              );
              if (Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2) < threshold)
                return true;
            }
          }
          return false;
        }
        draw(ctx, isSelected) {
          ctx.save();
          ctx.strokeStyle = isSelected ? "#4299E1" : "#4A5568";
          ctx.lineWidth = isSelected ? 3 : 1.5;
          ctx.fillStyle = ctx.strokeStyle;

          if (this.isSelfLoop) {
            const { startPos, endPos, cp1, cp2 } = this.getControlPoints();
            ctx.beginPath();
            ctx.moveTo(startPos.x, startPos.y);
            ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, endPos.x, endPos.y);
            ctx.stroke();
            const arrowLength = 15,
              arrowAngle = Math.PI / 6,
              tangentAngle = Math.atan2(endPos.y - cp2.y, endPos.x - cp2.x);
            ctx.beginPath();
            ctx.moveTo(endPos.x, endPos.y);
            ctx.lineTo(
              endPos.x - arrowLength * Math.cos(tangentAngle - arrowAngle),
              endPos.y - arrowLength * Math.sin(tangentAngle - arrowAngle)
            );
            ctx.lineTo(
              endPos.x - arrowLength * Math.cos(tangentAngle + arrowAngle),
              endPos.y - arrowLength * Math.sin(tangentAngle + arrowAngle)
            );
            ctx.closePath();
            ctx.fill();
          } else {
            const { cp } = this.getControlPoints();
            const start = this.startState,
              end = this.endState;
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.quadraticCurveTo(cp.x, cp.y, end.x, end.y);
            ctx.stroke();
            const endAngle = Math.atan2(end.y - cp.y, end.x - cp.x),
              arrowLength = 15,
              arrowAngle = Math.PI / 6;
            const distFromEnd = Math.sqrt(
              (end.x - cp.x) ** 2 + (end.y - cp.y) ** 2
            );
            if (distFromEnd > end.radius) {
              const t = (distFromEnd - end.radius) / distFromEnd;
              const finalEndPointX = (1 - t) * cp.x + t * end.x,
                finalEndPointY = (1 - t) * cp.y + t * end.y;
              ctx.beginPath();
              ctx.moveTo(finalEndPointX, finalEndPointY);
              ctx.lineTo(
                finalEndPointX - arrowLength * Math.cos(endAngle - arrowAngle),
                finalEndPointY - arrowLength * Math.sin(endAngle - arrowAngle)
              );
              ctx.lineTo(
                finalEndPointX - arrowLength * Math.cos(endAngle + arrowAngle),
                finalEndPointY - arrowLength * Math.sin(endAngle + arrowAngle)
              );
              ctx.closePath();
              ctx.fill();
            }
          }

          const baseLabelPos = this.getBaseLabelPosition();
          const textX = baseLabelPos.x + this.labelOffsetX;
          const textY = baseLabelPos.y + this.labelOffsetY;
          ctx.font = `${globalFontSize}px Sarabun`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          const textMetrics = ctx.measureText(this.text);
          ctx.fillStyle = "#f0f4f8";
          ctx.fillRect(
            textX - textMetrics.width / 2 - 4,
            textY - globalFontSize / 2 - 2,
            textMetrics.width + 8,
            globalFontSize + 4
          );
          ctx.fillStyle = "#2D3748";
          ctx.fillText(this.text, textX, textY);

          ctx.restore();
        }
      }

      // --- Main Application Logic ---
      const canvas = document.getElementById("fsm-canvas");
      const ctx = canvas.getContext("2d");
      const testStringInput = document.getElementById("test-string");
      const resultDiv = document.getElementById("result");
      const selectionEditor = document.getElementById("selection-editor");
      const editorTitle = document.getElementById("editor-title");
      const editorContent = document.getElementById("editor-content");
      const decreaseFontBtn = document.getElementById("decrease-font");
      const increaseFontBtn = document.getElementById("increase-font");
      const fontSizeDisplay = document.getElementById("font-size-display");
      const exportPngBtn = document.getElementById("export-png-btn");
      const exportTransparentPngBtn = document.getElementById(
        "export-transparent-png-btn"
      );

      let states = [];
      let transitions = [];
      let selectedObject = null;
      let currentState = null;
      let dragAction = null;

      function resizeCanvas() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = Math.max(container.clientHeight, 500);
        draw();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGuideLines();
        transitions.forEach((t) => t.draw(ctx, t === selectedObject));
        states.forEach((s) => {
          s.draw(ctx, s === selectedObject, s === currentState);
          if (s.isStart) drawStartArrow(s);
        });

        if (dragAction && dragAction.type === "create_link") {
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(dragAction.startState.x, dragAction.startState.y);
          ctx.lineTo(dragAction.currentX, dragAction.currentY);
          ctx.strokeStyle = "#4A5568";
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.stroke();
          ctx.restore();
        }
      }

      function drawGuideLines() {
        ctx.save();
        ctx.strokeStyle = "rgba(0, 150, 255, 0.7)";
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        guideLines.forEach((line) => {
          ctx.beginPath();
          if (line.type === "v") {
            ctx.moveTo(line.x, 0);
            ctx.lineTo(line.x, canvas.height);
          } else {
            // 'h'
            ctx.moveTo(0, line.y);
            ctx.lineTo(canvas.width, line.y);
          }
          ctx.stroke();
        });
        ctx.restore();
      }

      function drawStartArrow(state) {
        const startX = state.x - state.radius - 45,
          startY = state.y;
        const endX = state.x - state.radius,
          endY = state.y;
        ctx.save();
        ctx.strokeStyle = "#4A5568";
        ctx.lineWidth = 2;
        ctx.fillStyle = ctx.strokeStyle;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        const angle = Math.atan2(endY - startY, endX - startX);
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(
          endX - 15 * Math.cos(angle - Math.PI / 6),
          endY - 15 * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          endX - 15 * Math.cos(angle + Math.PI / 6),
          endY - 15 * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
      }

      canvas.addEventListener("mousedown", (e) => {
        const pos = getMousePos(e);
        let newSelectedObject = null;
        dragAction = null;

        // Priority 1: Check for label drag
        for (const t of transitions) {
          if (t.labelContains(ctx, pos.x, pos.y)) {
            newSelectedObject = t;
            dragAction = {
              type: "move_label",
              transition: t,
              startX: pos.x,
              startY: pos.y,
              initialOffsetX: t.labelOffsetX,
              initialOffsetY: t.labelOffsetY,
            };
            break;
          }
        }

        // Priority 2: Check for state move/link
        if (!dragAction) {
          for (const s of states) {
            if (s.contains(pos.x, pos.y)) {
              newSelectedObject = s;
              if (e.shiftKey) {
                dragAction = {
                  type: "create_link",
                  startState: s,
                  currentX: pos.x,
                  currentY: pos.y,
                };
              } else {
                dragAction = { type: "move_state", state: s };
              }
              break;
            }
          }
        }

        // Priority 3: Check for anchor move
        if (!dragAction) {
          for (const t of transitions) {
            if (t.contains(pos.x, pos.y)) {
              newSelectedObject = t;
              dragAction = { type: "move_anchor", transition: t };
              break;
            }
          }
        }

        if (!dragAction) {
          selectedObject = null;
        } else {
          selectedObject = newSelectedObject;
        }

        updateEditorPanel();
        draw();
      });

      canvas.addEventListener("mousemove", (e) => {
        if (!dragAction) return;
        const pos = getMousePos(e);
        guideLines = [];

        if (dragAction.type === "move_label") {
          const dx = pos.x - dragAction.startX;
          const dy = pos.y - dragAction.startY;
          dragAction.transition.labelOffsetX = dragAction.initialOffsetX + dx;
          dragAction.transition.labelOffsetY = dragAction.initialOffsetY + dy;
        } else if (dragAction.type === "move_state") {
          const draggedState = dragAction.state;
          let snapX = pos.x;
          let snapY = pos.y;
          const snapThreshold = 5;

          for (const otherState of states) {
            if (otherState === draggedState) continue;
            if (Math.abs(pos.x - otherState.x) < snapThreshold) {
              snapX = otherState.x;
              guideLines.push({ type: "v", x: otherState.x });
            }
            if (Math.abs(pos.y - otherState.y) < snapThreshold) {
              snapY = otherState.y;
              guideLines.push({ type: "h", y: otherState.y });
            }
          }
          draggedState.x = snapX;
          draggedState.y = snapY;
        } else if (dragAction.type === "create_link") {
          dragAction.currentX = pos.x;
          dragAction.currentY = pos.y;
        } else if (dragAction.type === "move_anchor") {
          const anchor = dragAction.transition;
          if (anchor.isSelfLoop) {
            anchor.anchorAngle = Math.atan2(
              pos.y - anchor.startState.y,
              pos.x - anchor.startState.x
            );
          } else {
            const dx = anchor.endState.x - anchor.startState.x,
              dy = anchor.endState.y - anchor.startState.y;
            const distSq = dx * dx + dy * dy;
            if (distSq === 0) return;
            const dot =
              (pos.x - anchor.startState.x) * -dy +
              (pos.y - anchor.startState.y) * dx;
            anchor.anchorAngle = Math.asin(
              Math.max(-1, Math.min(1, dot / distSq))
            );
          }
        }
        draw();
      });

      canvas.addEventListener("mouseup", (e) => {
        if (dragAction && dragAction.type === "create_link") {
          const pos = getMousePos(e);
          let targetState = null;
          for (const s of states) {
            if (s.contains(pos.x, pos.y)) {
              targetState = s;
              break;
            }
          }
          if (targetState) {
            const startState = dragAction.startState;
            const exists = transitions.some(
              (t) => t.startState === startState && t.endState === targetState
            );
            if (!exists) {
              const newTransition = new Transition(startState, targetState);
              transitions.push(newTransition);
              selectedObject = newTransition;
              updateEditorPanel();
            }
          }
        }
        dragAction = null;
        guideLines = [];
        draw();
        simulateFSM();
      });

      canvas.addEventListener("dblclick", (e) => {
        const pos = getMousePos(e);
        if (!states.some((s) => s.contains(pos.x, pos.y))) {
          const newState = new State(pos.x, pos.y);
          states.push(newState);
          selectedObject = newState;
          updateEditorPanel();
          draw();
        }
      });
      window.addEventListener("keydown", (e) => {
        const activeEl = document.activeElement;
        if (
          activeEl === testStringInput ||
          activeEl.id === "transition-text-input"
        )
          return;
        if (selectedObject && !e.shiftKey) {
          if (e.key === "Backspace") {
            e.preventDefault();
            if (
              selectedObject.text.length > 0 &&
              selectedObject instanceof State
            ) {
              selectedObject.text = selectedObject.text.slice(0, -1);
              updateEditorPanel();
            }
          } else if (e.key === "Delete") {
            e.preventDefault();
            deleteSelectedObject();
          } else if (e.key.length === 1 && selectedObject instanceof State) {
            selectedObject.text += e.key;
            updateEditorPanel();
          }
          draw();
          simulateFSM();
        }
      });
      function updateEditorPanel() {
        if (selectedObject instanceof State) {
          selectionEditor.classList.remove("hidden");
          editorTitle.textContent = `แก้ไขสถานะ: ${
            selectedObject.text || "(ไม่มีชื่อ)"
          }`;
          editorContent.innerHTML = `<button id="set-start-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition">ตั้งเป็นสถานะเริ่มต้น</button><button id="toggle-accept-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded transition">สลับสถานะยอมรับ</button><button id="delete-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded transition mt-4">ลบสถานะนี้</button>`;
          document.getElementById("set-start-btn").onclick = () => {
            states.forEach((s) => (s.isStart = false));
            selectedObject.isStart = true;
            draw();
            simulateFSM();
          };
          document.getElementById("toggle-accept-btn").onclick = () => {
            selectedObject.isAccept = !selectedObject.isAccept;
            draw();
            simulateFSM();
          };
          document.getElementById("delete-btn").onclick = deleteSelectedObject;
        } else if (selectedObject instanceof Transition) {
          selectionEditor.classList.remove("hidden");
          editorTitle.textContent = `แก้ไขเส้นเชื่อม`;
          editorContent.innerHTML = `<div><label for="transition-text-input" class="block text-sm font-medium text-gray-700">เงื่อนไข:</label><input type="text" id="transition-text-input" value="${selectedObject.text}" class="w-full p-2 mt-1 border border-gray-300 rounded-md"></div><button id="delete-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded transition mt-4">ลบเส้นเชื่อมนี้</button>`;
          const transitionInput = document.getElementById(
            "transition-text-input"
          );
          transitionInput.oninput = (e) => {
            selectedObject.text = e.target.value;
            draw();
            simulateFSM();
          };
          transitionInput.focus();
          document.getElementById("delete-btn").onclick = deleteSelectedObject;
        } else {
          selectionEditor.classList.add("hidden");
          editorContent.innerHTML = "";
        }
      }
      function deleteSelectedObject() {
        if (!selectedObject) return;
        if (selectedObject instanceof State) {
          states = states.filter((s) => s !== selectedObject);
          transitions = transitions.filter(
            (t) =>
              t.startState !== selectedObject && t.endState !== selectedObject
          );
        } else if (selectedObject instanceof Transition) {
          transitions = transitions.filter((t) => t !== selectedObject);
        }
        selectedObject = null;
        updateEditorPanel();
        draw();
        simulateFSM();
      }
      testStringInput.addEventListener("input", simulateFSM);
      function simulateFSM() {
        const input = testStringInput.value;
        let startState = states.find((s) => s.isStart);
        currentState = startState;
        if (!startState) {
          resultDiv.textContent = "โปรดกำหนดสถานะเริ่มต้น";
          resultDiv.className =
            "mt-3 text-lg font-semibold text-center h-8 text-yellow-600";
          draw();
          return;
        }
        let accepted = false,
          pathIsValid = true;
        for (const char of input) {
          const nextTransition = transitions.find(
            (t) => t.startState === currentState && t.text.includes(char)
          );
          if (nextTransition) {
            currentState = nextTransition.endState;
          } else {
            currentState = null;
            pathIsValid = false;
            break;
          }
        }
        if (pathIsValid && currentState && currentState.isAccept) {
          accepted = true;
        }
        if (input.length === 0) {
          resultDiv.textContent = "กำลังรอการป้อนข้อมูล...";
          resultDiv.className =
            "mt-3 text-lg font-semibold text-center h-8 text-gray-500";
        } else if (accepted) {
          resultDiv.textContent = "ยอมรับ (Accepted)";
          resultDiv.className =
            "mt-3 text-lg font-semibold text-center h-8 text-green-600";
        } else {
          resultDiv.textContent = "ปฏิเสธ (Rejected)";
          resultDiv.className =
            "mt-3 text-lg font-semibold text-center h-8 text-red-600";
        }
        draw();
      }
      function setupInitialFSM() {
        const s0 = new State(150, 200);
        s0.text = "q0";
        s0.isStart = true;
        const s1 = new State(350, 200);
        s1.text = "q1";
        const s2 = new State(550, 200);
        s2.text = "q2";
        s2.isAccept = true;
        states.push(s0, s1, s2);
        const t1 = new Transition(s0, s1);
        t1.text = "a";
        const t2 = new Transition(s1, s2);
        t2.text = "b";
        const t3 = new Transition(s2, s2);
        t3.text = "b";
        transitions.push(t1, t2, t3);
      }

      decreaseFontBtn.addEventListener("click", () => {
        if (globalFontSize > 8) {
          globalFontSize--;
          fontSizeDisplay.textContent = globalFontSize;
          draw();
        }
      });
      increaseFontBtn.addEventListener("click", () => {
        if (globalFontSize < 32) {
          globalFontSize++;
          fontSizeDisplay.textContent = globalFontSize;
          draw();
        }
      });

      function exportCanvasAsPNG(transparent = false) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!transparent) {
          ctx.fillStyle = "#f0f4f8";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        transitions.forEach((t) => t.draw(ctx, false));
        states.forEach((s) => {
          s.draw(ctx, false, false);
          if (s.isStart) drawStartArrow(s);
        });
        const dataURL = canvas.toDataURL("image/png");
        const link = document.createElement("a");
        link.download = transparent ? "fsm-transparent.png" : "fsm.png";
        link.href = dataURL;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        draw();
      }

      exportPngBtn.addEventListener("click", () => exportCanvasAsPNG(false));
      exportTransparentPngBtn.addEventListener("click", () =>
        exportCanvasAsPNG(true)
      );

      // --- Initialization ---
      window.addEventListener("resize", resizeCanvas);
      setupInitialFSM();
      resizeCanvas();
      simulateFSM();
    </script>
  </body>
</html>
