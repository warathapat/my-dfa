<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>เครื่องมือสร้าง Finite State Machine (Dark Mode & UI Update)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f0f4f8;
            --main-bg-color: #f3f4f6;
            --text-color: #1f2937;
            --info-box-bg: rgba(255, 255, 255, 0.9);
            --info-box-border: #e5e7eb;
            --input-bg: #ffffff;
            --input-border: #d1d5db;
            --state-bg: white;
            --state-stroke: #4A5568;
            --state-text: #2D3748;
        }
        html.dark {
            --bg-color: #111827;
            --main-bg-color: #1f2937;
            --text-color: #d1d5db;
            --info-box-bg: rgba(31, 41, 55, 0.9);
            --info-box-border: #4b5563;
            --input-bg: #374151;
            --input-border: #6b7280;
            --state-bg: #4b5563;
            --state-stroke: #d1d5db;
            --state-text: #f9fafb;
        }
        body {
            font-family: 'Sarabun', sans-serif;
            touch-action: none;
            background-color: var(--main-bg-color);
            color: var(--text-color);
        }
        canvas {
            cursor: crosshair;
            background-color: var(--bg-color);
            border-radius: 0.5rem;
        }
        .info-box {
            background-color: var(--info-box-bg);
            border: 1px solid var(--info-box-border);
            backdrop-filter: blur(5px);
        }
        input[type="text"] {
            background-color: var(--input-bg);
            border-color: var(--input-border);
            color: var(--text-color);
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-6xl mx-auto">
        <h1 id="main-title" class="text-3xl font-bold text-center mb-4"></h1>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
            <!-- Canvas Area -->
            <div class="lg:col-span-2 bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md">
                <canvas id="fsm-canvas"></canvas>
            </div>

            <!-- Controls and Info Area -->
            <div class="flex flex-col gap-4">
                <div class="flex justify-between items-center gap-2">
                    <div class="flex gap-1">
                        <button id="lang-th-btn" class="font-bold py-2 px-4 rounded transition text-white"></button>
                        <button id="lang-en-btn" class="font-bold py-2 px-4 rounded transition text-white"></button>
                    </div>
                    <button id="dark-mode-toggle" class="p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200">
                        <!-- Moon Icon -->
                        <svg id="moon-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                        <!-- Sun Icon -->
                        <svg id="sun-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun hidden"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                    </button>
                </div>

                <div class="info-box p-4 rounded-lg shadow-md">
                    <h2 id="test-string-header" class="text-xl font-bold mb-3"></h2>
                    <input type="text" id="test-string" class="w-full p-2 border rounded-md focus:ring-2 focus:ring-blue-500 transition">
                    <div id="result" class="mt-3 text-lg font-semibold text-center h-8"></div>
                </div>

                <div id="selection-editor" class="info-box p-4 rounded-lg shadow-md hidden">
                    <h2 class="text-xl font-bold mb-3" id="editor-title"></h2>
                    <div id="editor-content" class="space-y-3"></div>
                </div>
                
                <div class="info-box p-4 rounded-lg shadow-md">
                    <h2 id="display-settings-header" class="text-xl font-bold mb-3"></h2>
                    <div class="flex items-center justify-center gap-4">
                        <label id="font-size-label" class=""></label>
                        <button id="decrease-font" class="px-3 py-1 bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 rounded-md font-bold">-</button>
                        <span id="font-size-display" class="w-8 text-center font-semibold">16</span>
                        <button id="increase-font" class="px-3 py-1 bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 rounded-md font-bold">+</button>
                    </div>
                </div>

                <div class="info-box p-4 rounded-lg shadow-md">
                    <h2 id="export-header" class="text-xl font-bold mb-3"></h2>
                    <div class="flex flex-col gap-2">
                        <button id="export-png-btn" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded transition"></button>
                        <button id="export-transparent-png-btn" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded transition"></button>
                    </div>
                </div>

                <div class="info-box p-4 rounded-lg shadow-md">
                    <h2 id="instructions-header" class="text-xl font-bold mb-3"></h2>
                    <ul id="instructions-list" class="list-disc list-inside space-y-2"></ul>
                </div>
            </div>
        </div>
    </div>
    <footer class="text-center text-sm text-gray-500 dark:text-gray-400 mt-8">
        Copyright © 2024 Warattapop T.
    </footer>

    <script>
        // --- UI Text Strings ---
        const uiStrings = {
            th: {
                mainTitle: "เครื่องมือสร้างและจำลอง Finite State Machine", testStringHeader: "ทดสอบสตริง", testStringPlaceholder: "ป้อนสตริงที่นี่...", resultWaiting: "กำลังรอการป้อนข้อมูล...", resultAccepted: "ยอมรับ (Accepted)", resultRejected: "ปฏิเสธ (Rejected)", resultNoStart: "โปรดกำหนดสถานะเริ่มต้น", editStateTitle: "แก้ไขสถานะ:", editTransitionTitle: "แก้ไขเส้นเชื่อม", noName: "(ไม่มีชื่อ)", setAsStart: "ตั้งเป็นสถานะเริ่มต้น", toggleAccept: "สลับสถานะยอมรับ", deleteThisState: "ลบสถานะนี้", conditionLabel: "เงื่อนไข:", deleteThisTransition: "ลบเส้นเชื่อมนี้", displaySettingsHeader: "ตั้งค่าการแสดงผล", fontSizeLabel: "ขนาดตัวอักษร:", exportHeader: "ส่งออกแผนภาพ", exportPng: "Export as PNG", exportTransparentPng: "Export as Transparent PNG", instructionsHeader: "วิธีใช้งาน",
                instructions: [
                    "<strong>ย้าย Label:</strong> คลิกค้างที่ข้อความของเส้นเชื่อมแล้วลาก", "<strong>ย้ายสถานะ:</strong> คลิกค้างแล้วลากสถานะ (จะมี Smart Guide ช่วยจัดตำแหน่ง)", "<strong>สร้างเส้นเชื่อม:</strong> กด <kbd class='px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg'>Shift</kbd> ค้างไว้ แล้วลากจากสถานะหนึ่งไปอีกสถานะ", "<strong>ปรับความโค้งเส้นเชื่อม:</strong> คลิกค้างที่กลางเส้นเชื่อมแล้วลาก", "<strong>ลบ:</strong> คลิกเลือกวัตถุแล้วกด <kbd>Delete</kbd> หรือใช้ปุ่มในเมนูแก้ไข",
                ]
            },
            en: {
                mainTitle: "Finite State Machine Designer & Simulator", testStringHeader: "Test String", testStringPlaceholder: "Enter string here...", resultWaiting: "Waiting for input...", resultAccepted: "Accepted", resultRejected: "Rejected", resultNoStart: "Please define a start state", editStateTitle: "Edit State:", editTransitionTitle: "Edit Transition", noName: "(unnamed)", setAsStart: "Set as Start State", toggleAccept: "Toggle Accept State", deleteThisState: "Delete this State", conditionLabel: "Condition:", deleteThisTransition: "Delete this Transition", displaySettingsHeader: "Display Settings", fontSizeLabel: "Font Size:", exportHeader: "Export Diagram", exportPng: "Export as PNG", exportTransparentPng: "Export as Transparent PNG", instructionsHeader: "Instructions",
                instructions: [
                    "<strong>Move Label:</strong> Click and drag a transition's label.", "<strong>Move State:</strong> Click and drag a state (smart guides will appear).", "<strong>Create Transition:</strong> Hold <kbd class='px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg'>Shift</kbd> and drag from one state to another.", "<strong>Adjust Curve:</strong> Click and drag the middle of a transition.", "<strong>Delete:</strong> Select an object and press <kbd>Delete</kbd> or use the editor menu.",
                ]
            }
        };

        // --- Global Settings ---
        let globalFontSize = 16;
        let guideLines = [];
        let currentLanguage = 'th';
        
        // --- Class Definitions ---
        class State {
            constructor(x, y) { this.x = x; this.y = y; this.radius = 30; this.text = ''; this.isAccept = false; this.isStart = false; }
            contains(x, y) { return Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2) < this.radius; }
            draw(ctx, isSelected, isCurrent) {
                const isDark = document.documentElement.classList.contains('dark');
                ctx.save();
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.fillStyle = isCurrent ? '#68D391' : (isDark ? '#4b5563' : 'white');
                ctx.fill();
                ctx.strokeStyle = isSelected ? '#4299E1' : (isDark ? '#d1d5db' : '#4A5568');
                ctx.lineWidth = isSelected ? 4 : 2; ctx.stroke();
                if (this.isAccept) { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius - 6, 0, 2 * Math.PI); ctx.strokeStyle = (isDark ? '#d1d5db' : '#4A5568'); ctx.lineWidth = 2; ctx.stroke(); }
                ctx.fillStyle = isDark ? '#f9fafb' : '#2D3748';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.font = `${globalFontSize}px Sarabun`;
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }
        }
        class Transition {
            constructor(startState, endState) {
                this.startState = startState; this.endState = endState; this.text = ''; this.anchorAngle = 0; this.isSelfLoop = startState === endState; this.labelOffsetX = 0; this.labelOffsetY = 0; if (this.isSelfLoop) { this.anchorAngle = -Math.PI / 2; }
            }
            getControlPoints() {
                if (this.isSelfLoop) {
                    const s = this.startState, r = s.radius, angle = this.anchorAngle, spread = Math.PI / 4, loopSize = 45;
                    const startAngle = angle - spread, endAngle = angle + spread;
                    const startPos = { x: s.x + r * Math.cos(startAngle), y: s.y + r * Math.sin(startAngle) };
                    const endPos = { x: s.x + r * Math.cos(endAngle), y: s.y + r * Math.sin(endAngle) };
                    const cpDist = r + loopSize;
                    const cp1 = { x: s.x + cpDist * Math.cos(angle - spread * 0.8), y: s.y + cpDist * Math.sin(angle - spread * 0.8) };
                    const cp2 = { x: s.x + cpDist * Math.cos(angle + spread * 0.8), y: s.y + cpDist * Math.sin(angle + spread * 0.8) };
                    return { startPos, endPos, cp1, cp2 };
                } else {
                    const dx = this.endState.x - this.startState.x, dy = this.endState.y - this.startState.y;
                    const dist = Math.sqrt(dx * dx + dy * dy); if (dist === 0) return { cp: { x: this.startState.x, y: this.startState.y } };
                    const normalX = -dy / dist, normalY = dx / dist;
                    const midX = this.startState.x + dx / 2, midY = this.startState.y + dy / 2;
                    const anchorLength = Math.sin(this.anchorAngle) * dist / 2;
                    const cp = { x: midX + normalX * anchorLength, y: midY + normalY * anchorLength };
                    return { cp };
                }
            }
            getPointOnQuadraticBezier(t, start, cp, end) { const x = (1 - t) * (1 - t) * start.x + 2 * (1 - t) * t * cp.x + t * t * end.x; const y = (1 - t) * (1 - t) * start.y + 2 * (1 - t) * t * cp.y + t * t * end.y; return { x, y }; }
            getPointOnCubicBezier(t, start, cp1, cp2, end) { const x = Math.pow(1 - t, 3) * start.x + 3 * Math.pow(1 - t, 2) * t * cp1.x + 3 * (1 - t) * t * t * cp2.x + Math.pow(t, 3) * end.x; const y = Math.pow(1 - t, 3) * start.y + 3 * Math.pow(1 - t, 2) * t * cp1.y + 3 * (1 - t) * t * t * cp2.y + Math.pow(t, 3) * end.y; return { x, y }; }
            getBaseLabelPosition() {
                if (this.isSelfLoop) {
                    const s = this.startState, r = s.radius, angle = this.anchorAngle, loopSize = 45;
                    const apex = { x: s.x + (r + loopSize + 10) * Math.cos(angle), y: s.y + (r + loopSize + 10) * Math.sin(angle) };
                    return apex;
                } else {
                    const { cp } = this.getControlPoints();
                    const start = this.startState, end = this.endState;
                    const midCurveX = 0.25 * start.x + 0.5 * cp.x + 0.25 * end.x;
                    const midCurveY = 0.25 * start.y + 0.5 * cp.y + 0.25 * end.y;
                    return { x: midCurveX, y: midCurveY };
                }
            }
            labelContains(ctx, x, y) {
                if (!this.text) return false;
                const basePos = this.getBaseLabelPosition();
                const finalX = basePos.x + this.labelOffsetX;
                const finalY = basePos.y + this.labelOffsetY;
                ctx.font = `${globalFontSize}px Sarabun`;
                const textMetrics = ctx.measureText(this.text);
                const width = textMetrics.width + 8;
                const height = globalFontSize + 4;
                return (x >= finalX - width / 2 && x <= finalX + width / 2 && y >= finalY - height / 2 && y <= finalY + height / 2);
            }
            contains(x, y) {
                const threshold = 15;
                if (this.isSelfLoop) {
                    const { startPos, endPos, cp1, cp2 } = this.getControlPoints();
                    for (let t = 0; t <= 1; t += 0.05) { const p = this.getPointOnCubicBezier(t, startPos, cp1, cp2, endPos); if (Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2) < threshold) return true; }
                } else {
                    const { cp } = this.getControlPoints();
                    for (let t = 0; t <= 1; t += 0.05) { const p = this.getPointOnQuadraticBezier(t, this.startState, cp, this.endState); if (Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2) < threshold) return true; }
                }
                return false;
            }
            draw(ctx, isSelected) {
                const isDark = document.documentElement.classList.contains('dark');
                ctx.save();
                ctx.strokeStyle = isSelected ? '#4299E1' : (isDark ? '#d1d5db' : '#4A5568');
                ctx.lineWidth = isSelected ? 3 : 1.5;
                ctx.fillStyle = ctx.strokeStyle;
                
                if (this.isSelfLoop) {
                    const { startPos, endPos, cp1, cp2 } = this.getControlPoints();
                    ctx.beginPath(); ctx.moveTo(startPos.x, startPos.y); ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, endPos.x, endPos.y); ctx.stroke();
                    const arrowLength = 15, arrowAngle = Math.PI / 6, tangentAngle = Math.atan2(endPos.y - cp2.y, endPos.x - cp2.x);
                    ctx.beginPath(); ctx.moveTo(endPos.x, endPos.y); ctx.lineTo(endPos.x - arrowLength * Math.cos(tangentAngle - arrowAngle), endPos.y - arrowLength * Math.sin(tangentAngle - arrowAngle)); ctx.lineTo(endPos.x - arrowLength * Math.cos(tangentAngle + arrowAngle), endPos.y - arrowLength * Math.sin(tangentAngle + arrowAngle)); ctx.closePath(); ctx.fill();
                } else {
                    const { cp } = this.getControlPoints(); const start = this.startState, end = this.endState;
                    ctx.beginPath(); ctx.moveTo(start.x, start.y); ctx.quadraticCurveTo(cp.x, cp.y, end.x, end.y); ctx.stroke();
                    const endAngle = Math.atan2(end.y - cp.y, end.x - cp.x), arrowLength = 15, arrowAngle = Math.PI / 6;
                    const distFromEnd = Math.sqrt((end.x - cp.x) ** 2 + (end.y - cp.y) ** 2);
                    if (distFromEnd > end.radius) {
                        const t = (distFromEnd - end.radius) / distFromEnd;
                        const finalEndPointX = (1 - t) * cp.x + t * end.x, finalEndPointY = (1 - t) * cp.y + t * end.y;
                        ctx.beginPath(); ctx.moveTo(finalEndPointX, finalEndPointY); ctx.lineTo(finalEndPointX - arrowLength * Math.cos(endAngle - arrowAngle), finalEndPointY - arrowLength * Math.sin(endAngle - arrowAngle)); ctx.lineTo(finalEndPointX - arrowLength * Math.cos(endAngle + arrowAngle), finalEndPointY - arrowLength * Math.sin(endAngle + arrowAngle)); ctx.closePath(); ctx.fill();
                    }
                }
                
                const baseLabelPos = this.getBaseLabelPosition();
                const textX = baseLabelPos.x + this.labelOffsetX;
                const textY = baseLabelPos.y + this.labelOffsetY;
                ctx.font = `${globalFontSize}px Sarabun`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                const textMetrics = ctx.measureText(this.text);
                ctx.fillStyle = isDark ? '#111827' : '#f0f4f8';
                ctx.fillRect(textX - textMetrics.width / 2 - 4, textY - globalFontSize / 2 - 2, textMetrics.width + 8, globalFontSize + 4);
                ctx.fillStyle = isDark ? '#f9fafb' : '#2D3748';
                ctx.fillText(this.text, textX, textY);

                ctx.restore();
            }
        }

        // --- Main Application Logic ---
        const canvas = document.getElementById('fsm-canvas');
        const ctx = canvas.getContext('2d');
        const testStringInput = document.getElementById('test-string');
        const resultDiv = document.getElementById('result');
        const selectionEditor = document.getElementById('selection-editor');
        const editorTitle = document.getElementById('editor-title');
        const editorContent = document.getElementById('editor-content');
        const decreaseFontBtn = document.getElementById('decrease-font');
        const increaseFontBtn = document.getElementById('increase-font');
        const fontSizeDisplay = document.getElementById('font-size-display');
        const exportPngBtn = document.getElementById('export-png-btn');
        const exportTransparentPngBtn = document.getElementById('export-transparent-png-btn');
        const langThBtn = document.getElementById('lang-th-btn');
        const langEnBtn = document.getElementById('lang-en-btn');
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const moonIcon = document.getElementById('moon-icon');
        const sunIcon = document.getElementById('sun-icon');

        let states = [];
        let transitions = [];
        let selectedObject = null;
        let currentState = null;
        let dragAction = null;

        function resizeCanvas() { const container = canvas.parentElement; canvas.width = container.clientWidth; canvas.height = Math.max(container.clientHeight, 500); draw(); }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGuideLines();
            transitions.forEach(t => t.draw(ctx, t === selectedObject));
            states.forEach(s => { s.draw(ctx, s === selectedObject, s === currentState); if (s.isStart) drawStartArrow(s); });
            
            if (dragAction && dragAction.type === 'create_link') {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(dragAction.startState.x, dragAction.startState.y);
                ctx.lineTo(dragAction.currentX, dragAction.currentY);
                ctx.strokeStyle = '#4A5568';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.restore();
            }
        }

        function drawGuideLines() {
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 150, 255, 0.7)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            guideLines.forEach(line => {
                ctx.beginPath();
                if (line.type === 'v') {
                    ctx.moveTo(line.x, 0);
                    ctx.lineTo(line.x, canvas.height);
                } else { // 'h'
                    ctx.moveTo(0, line.y);
                    ctx.lineTo(canvas.width, line.y);
                }
                ctx.stroke();
            });
            ctx.restore();
        }

        function drawStartArrow(state) {
            const isDark = document.documentElement.classList.contains('dark');
            const startX = state.x - state.radius - 45, startY = state.y; const endX = state.x - state.radius, endY = state.y;
            ctx.save(); 
            ctx.strokeStyle = isDark ? '#d1d5db' : '#4A5568';
            ctx.lineWidth = 2; ctx.fillStyle = ctx.strokeStyle;
            ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY); ctx.stroke();
            const angle = Math.atan2(endY - startY, endX - startX);
            ctx.beginPath(); ctx.moveTo(endX, endY); ctx.lineTo(endX - 15 * Math.cos(angle - Math.PI / 6), endY - 15 * Math.sin(angle - Math.PI / 6)); ctx.lineTo(endX - 15 * Math.cos(angle + Math.PI / 6), endY - 15 * Math.sin(angle + Math.PI / 6)); ctx.closePath(); ctx.fill();
            ctx.restore();
        }
        function getMousePos(evt) { const rect = canvas.getBoundingClientRect(); return { x: evt.clientX - rect.left, y: evt.clientY - rect.top }; }

        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);
            let newSelectedObject = null;
            dragAction = null;

            for (const t of transitions) {
                if (t.labelContains(ctx, pos.x, pos.y)) {
                    newSelectedObject = t;
                    dragAction = { type: 'move_label', transition: t, startX: pos.x, startY: pos.y, initialOffsetX: t.labelOffsetX, initialOffsetY: t.labelOffsetY };
                    break;
                }
            }
            if (!dragAction) {
                for (const s of states) {
                    if (s.contains(pos.x, pos.y)) {
                        newSelectedObject = s;
                        if (e.shiftKey) {
                            dragAction = { type: 'create_link', startState: s, currentX: pos.x, currentY: pos.y };
                        } else {
                            dragAction = { type: 'move_state', state: s };
                        }
                        break;
                    }
                }
            }
            if (!dragAction) {
                for (const t of transitions) {
                    if (t.contains(pos.x, pos.y)) {
                        newSelectedObject = t;
                        dragAction = { type: 'move_anchor', transition: t };
                        break;
                    }
                }
            }
            
            if (!dragAction) {
                selectedObject = null;
            } else {
                selectedObject = newSelectedObject;
            }

            updateEditorPanel();
            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!dragAction) return;
            const pos = getMousePos(e);
            guideLines = [];

            if (dragAction.type === 'move_label') {
                const dx = pos.x - dragAction.startX;
                const dy = pos.y - dragAction.startY;
                dragAction.transition.labelOffsetX = dragAction.initialOffsetX + dx;
                dragAction.transition.labelOffsetY = dragAction.initialOffsetY + dy;
            } else if (dragAction.type === 'move_state') {
                const draggedState = dragAction.state;
                let snapX = pos.x;
                let snapY = pos.y;
                const snapThreshold = 5;

                for (const otherState of states) {
                    if (otherState === draggedState) continue;
                    if (Math.abs(pos.x - otherState.x) < snapThreshold) {
                        snapX = otherState.x;
                        guideLines.push({ type: 'v', x: otherState.x });
                    }
                    if (Math.abs(pos.y - otherState.y) < snapThreshold) {
                        snapY = otherState.y;
                        guideLines.push({ type: 'h', y: otherState.y });
                    }
                }
                draggedState.x = snapX;
                draggedState.y = snapY;

            } else if (dragAction.type === 'create_link') {
                dragAction.currentX = pos.x;
                dragAction.currentY = pos.y;
            } else if (dragAction.type === 'move_anchor') {
                const anchor = dragAction.transition;
                if (anchor.isSelfLoop) { anchor.anchorAngle = Math.atan2(pos.y - anchor.startState.y, pos.x - anchor.startState.x); } 
                else { const dx = anchor.endState.x - anchor.startState.x, dy = anchor.endState.y - anchor.startState.y; const distSq = dx * dx + dy * dy; if (distSq === 0) return; const dot = (pos.x - anchor.startState.x) * (-dy) + (pos.y - anchor.startState.y) * dx; anchor.anchorAngle = Math.asin(Math.max(-1, Math.min(1, dot / distSq))); }
            }
            draw();
        });

        canvas.addEventListener('mouseup', (e) => {
            if (dragAction && dragAction.type === 'create_link') {
                const pos = getMousePos(e);
                let targetState = null;
                for (const s of states) {
                    if (s.contains(pos.x, pos.y)) {
                        targetState = s;
                        break;
                    }
                }
                if (targetState) {
                    const startState = dragAction.startState;
                    const exists = transitions.some(t => t.startState === startState && t.endState === targetState);
                    if (!exists) {
                        const newTransition = new Transition(startState, targetState);
                        transitions.push(newTransition);
                        selectedObject = newTransition;
                        updateEditorPanel();
                    }
                }
            }
            dragAction = null;
            guideLines = [];
            draw();
            simulateFSM();
        });

        canvas.addEventListener('dblclick', (e) => { const pos = getMousePos(e); if (!states.some(s => s.contains(pos.x, pos.y))) { const newState = new State(pos.x, pos.y); states.push(newState); selectedObject = newState; updateEditorPanel(); draw(); } });
        window.addEventListener('keydown', (e) => {
            const activeEl = document.activeElement; if (activeEl === testStringInput || activeEl.id === 'transition-text-input') return;
            if (selectedObject && !e.shiftKey) {
                if (e.key === 'Backspace') { e.preventDefault(); if (selectedObject.text.length > 0 && selectedObject instanceof State) { selectedObject.text = selectedObject.text.slice(0, -1); updateEditorPanel(); } } 
                else if (e.key === 'Delete') { e.preventDefault(); deleteSelectedObject(); } 
                else if (e.key.length === 1 && selectedObject instanceof State) { selectedObject.text += e.key; updateEditorPanel(); }
                draw(); simulateFSM();
            }
        });

        function setLanguage(lang) {
            currentLanguage = lang;
            document.documentElement.lang = lang;
            const strings = uiStrings[lang];

            document.getElementById('main-title').textContent = strings.mainTitle;
            document.getElementById('test-string-header').textContent = strings.testStringHeader;
            document.getElementById('test-string').placeholder = strings.testStringPlaceholder;
            document.getElementById('display-settings-header').textContent = strings.displaySettingsHeader;
            document.getElementById('font-size-label').textContent = strings.fontSizeLabel;
            document.getElementById('export-header').textContent = strings.exportHeader;
            document.getElementById('export-png-btn').textContent = strings.exportPng;
            document.getElementById('export-transparent-png-btn').textContent = strings.exportTransparentPng;
            document.getElementById('instructions-header').textContent = strings.instructionsHeader;
            
            const instructionList = document.getElementById('instructions-list');
            instructionList.innerHTML = '';
            strings.instructions.forEach(item => {
                const li = document.createElement('li');
                li.innerHTML = item;
                instructionList.appendChild(li);
            });
            
            langThBtn.textContent = "TH";
            langEnBtn.textContent = "EN";
            
            if (lang === 'th') {
                langThBtn.classList.add('bg-green-500');
                langThBtn.classList.remove('bg-gray-500');
                langEnBtn.classList.add('bg-gray-500');
                langEnBtn.classList.remove('bg-green-500');
            } else {
                langEnBtn.classList.add('bg-green-500');
                langEnBtn.classList.remove('bg-gray-500');
                langThBtn.classList.add('bg-gray-500');
                langThBtn.classList.remove('bg-green-500');
            }


            updateEditorPanel();
            simulateFSM();
        }

        function updateEditorPanel() {
            const strings = uiStrings[currentLanguage];
            if (selectedObject instanceof State) {
                selectionEditor.classList.remove('hidden'); 
                editorTitle.textContent = `${strings.editStateTitle} ${selectedObject.text || strings.noName}`;
                editorContent.innerHTML = `
                    <button id="set-start-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition">${strings.setAsStart}</button>
                    <button id="toggle-accept-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded transition">${strings.toggleAccept}</button>
                    <button id="delete-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded transition mt-4">${strings.deleteThisState}</button>
                `;
                document.getElementById('set-start-btn').onclick = () => { states.forEach(s => s.isStart = false); selectedObject.isStart = true; draw(); simulateFSM(); };
                document.getElementById('toggle-accept-btn').onclick = () => { selectedObject.isAccept = !selectedObject.isAccept; draw(); simulateFSM(); };
                document.getElementById('delete-btn').onclick = deleteSelectedObject;
            } else if (selectedObject instanceof Transition) {
                selectionEditor.classList.remove('hidden'); 
                editorTitle.textContent = strings.editTransitionTitle;
                editorContent.innerHTML = `
                    <div>
                        <label for="transition-text-input" class="block text-sm font-medium">${strings.conditionLabel}</label>
                        <input type="text" id="transition-text-input" value="${selectedObject.text}" class="w-full p-2 mt-1 border rounded-md">
                    </div>
                    <button id="delete-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded transition mt-4">${strings.deleteThisTransition}</button>
                `;
                const transitionInput = document.getElementById('transition-text-input');
                transitionInput.oninput = (e) => { selectedObject.text = e.target.value; draw(); simulateFSM(); };
                transitionInput.focus(); 
                document.getElementById('delete-btn').onclick = deleteSelectedObject;
            } else { 
                selectionEditor.classList.add('hidden'); 
                editorContent.innerHTML = ''; 
            }
        }
        function deleteSelectedObject() {
            if (!selectedObject) return;
            if (selectedObject instanceof State) { states = states.filter(s => s !== selectedObject); transitions = transitions.filter(t => t.startState !== selectedObject && t.endState !== selectedObject); } 
            else if (selectedObject instanceof Transition) { transitions = transitions.filter(t => t !== selectedObject); }
            selectedObject = null; updateEditorPanel(); draw(); simulateFSM();
        }
        
        function simulateFSM() {
            try {
                const strings = uiStrings[currentLanguage];
                const input = testStringInput.value;
                let startState = states.find(s => s.isStart);

                if (!startState) {
                    currentState = null;
                    resultDiv.textContent = strings.resultNoStart;
                    resultDiv.className = 'mt-3 text-lg font-semibold text-center h-8 text-yellow-600';
                    draw();
                    return;
                }

                let localCurrentState = startState;
                let pathIsValid = true;
                for (const char of input) {
                    if (!localCurrentState) {
                        pathIsValid = false;
                        break;
                    }
                    const nextTransition = transitions.find(t => t.startState === localCurrentState && t.text.includes(char));
                    if (nextTransition) {
                        localCurrentState = nextTransition.endState;
                    } else {
                        localCurrentState = null;
                        pathIsValid = false;
                        break;
                    }
                }
                
                currentState = localCurrentState;

                const accepted = pathIsValid && currentState && currentState.isAccept;

                if (input.length === 0) {
                    resultDiv.textContent = strings.resultWaiting;
                    resultDiv.className = 'mt-3 text-lg font-semibold text-center h-8 text-gray-500 dark:text-gray-400';
                } else if (accepted) {
                    resultDiv.textContent = strings.resultAccepted;
                    resultDiv.className = 'mt-3 text-lg font-semibold text-center h-8 text-green-600';
                } else {
                    resultDiv.textContent = strings.resultRejected;
                    resultDiv.className = 'mt-3 text-lg font-semibold text-center h-8 text-red-600';
                }

                draw();
            } catch (error) {
                console.error("Error during FSM simulation:", error);
            }
        }
        
        function setupInitialFSM() {
            const s0 = new State(150, 200); s0.text = 'q0'; s0.isStart = true; const s1 = new State(350, 200); s1.text = 'q1'; const s2 = new State(550, 200); s2.text = 'q2'; s2.isAccept = true;
            states.push(s0, s1, s2);
            const t1 = new Transition(s0, s1); t1.text = 'a'; const t2 = new Transition(s1, s2); t2.text = 'b'; const t3 = new Transition(s2, s2); t3.text = 'b';
            transitions.push(t1, t2, t3);
        }
        
        // --- Event Listeners for new controls ---
        decreaseFontBtn.addEventListener('click', () => {
            if (globalFontSize > 8) { globalFontSize--; fontSizeDisplay.textContent = globalFontSize; draw(); }
        });
        increaseFontBtn.addEventListener('click', () => {
            if (globalFontSize < 32) { globalFontSize++; fontSizeDisplay.textContent = globalFontSize; draw(); }
        });
        
        langThBtn.addEventListener('click', () => setLanguage('th'));
        langEnBtn.addEventListener('click', () => setLanguage('en'));

        darkModeToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
            if (document.documentElement.classList.contains('dark')) {
                moonIcon.classList.add('hidden');
                sunIcon.classList.remove('hidden');
            } else {
                moonIcon.classList.remove('hidden');
                sunIcon.classList.add('hidden');
            }
            draw();
        });

        testStringInput.addEventListener('input', simulateFSM);

        function exportCanvasAsPNG(transparent = false) {
            const isDark = document.documentElement.classList.contains('dark');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!transparent) {
                ctx.fillStyle = isDark ? '#111827' : '#f0f4f8';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            transitions.forEach(t => t.draw(ctx, false));
            states.forEach(s => {
                s.draw(ctx, false, false);
                if (s.isStart) drawStartArrow(s);
            });
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = transparent ? 'fsm-transparent.png' : 'fsm.png';
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            draw();
        }

        exportPngBtn.addEventListener('click', () => exportCanvasAsPNG(false));
        exportTransparentPngBtn.addEventListener('click', () => exportCanvasAsPNG(true));


        // --- Initialization ---
        window.addEventListener('resize', resizeCanvas);
        setupInitialFSM();
        resizeCanvas();
        setLanguage(currentLanguage);
    </script>
</body>
</html>
